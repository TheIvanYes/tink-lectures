# Sparse tables
(опираюсь на [алгоритмику](https://algorithmica.org/ru/sparse-table))
Мы обсуждали префиксные суммы - но префиксные суммы не умеют считать, к примеру минимум на отрезке (при неизменном массиве). Вводим новую структуру данных - sparse table, которая будет строиться за $O(n \log n)$ и выполнять взятие минимума/максимума за $O(1)$ (тоже при неизменном отрезке).

Что такое sparse table - таблица $st$, размером $\log(n) \times n$, в $st_{i,j}$ лежит минимум на отрезке $[j, j + 2^i - 1]$
Как мы ее будем строить:
```cpp
int a[maxn], mn[logn][maxn];
// инициализация вектора, logn - максимально возможный логарифм от длины отрезка.
for (int i = 0; i < n; i++) {
  mn[0][i] = a[i];
} // или же
memcpy(mn[0], a, sizeof a);

for (int l = 0; l < logn - 1; l++)
    for (int i = 0; i + (2 << l) <= n; i++)
        mn[l+1][i] = min(mn[l][i], mn[l][i + (1 << l)]);
```

Теперь как брать минимум:
```cpp
int rmq(int l, int r) { // полуинтервал [l; r)
    int t = __lg(r - l);
    return min(mn[t][l], mn[t][r - (1 << t)]);
}

```

Можно брать любую операцию, которая ассоцитативна, коммутативна и идемпотентна (то есть min, max, gcd подойдут).

Можно построить двухмерные спарсы (по аналогии с двумерными префиксными суммами), тогда надо будет брать минимум на подпрямоугольниках (таблица будет вида mn[l][i][j]).

# Сверху
Теперь мы приходим к задаче "взять минимум/максимум/сумму/любую операцию на отрезке, изменить в точке" или "взять значение в точке, сделать += на отрезке"
Объяснение сверху, код

# Cнизу
Дерево отрезков снизу банально быстрее из-за отсутствия рекурсии и меньшего объема памяти. Но дерево отрезков снизу не умеет многое, что умеет ДО сверху, хотя оно также очень понятно.
код


# Спуск по дереву

Пример задачи, для которой требуется простой спуск по дереву (с левой границей = 0) - поиск k-го нуля в массиве.
```cpp

```

Пример задачи, для которой требуются спуски - поиск первого минимума на отрезке [l, r].

примерный код спусков:
```cpp
const int N = 2e5;
int t[N];

std::pair<int, int> find_k_th_zero(int v, int tl, int tr, int l, int k) {
    if (tr < l) {
        return {-1, 0};
    }
    if (t[v] < k && tl >= l) {
        return {-1, t[v]}; 
    }
    if (tl == tr && k == 1) {
        return {tl, 1};
    }
    int tm = (tl + tr) / 2;
    std::pair<int, int> res = {-1, -1};
    auto res = find_k_th_zero(2 * v, tl, tm, l, k);
    auto res2 = res;
    if (res.first == -1) {
        int cnt = t[2 * v];
        res2 = find_k_th_zero(2 * v + 1, tm + 1, tr, l, k - res.second);
        res2.second += res2.first;
    }
    return res2;
}
```


